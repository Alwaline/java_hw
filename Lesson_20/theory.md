# Работа с ошибками

* Ошибки (в программировании) - реакция системы на какую-либо некорректную ситуацию
  * Ошибки компиляции - когда неправильно написан исходный код

```
C:\Users\AiT\IdeaProjects\Lesson_19\src\ru.itis.users.app.Main.java:3:9
java: cannot find symbol
  symbol:   variable a
  location: class ru.itis.users.app.Main
```

  * Ошибки времени выполнения - происходит во время работы программы
    * Некорректные данные, которые программа получила извне

При вводе нулевого значения в качестве переменной `b` мы получим ошибку

```
Scanner scanner = new Scanner(System.in);

int a = scanner.nextInt();
int b = scanner.nextInt();

int c = a / b;
```

Текст ошибки

```
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at ru.itis.users.app.Main.main(ru.itis.users.app.Main.java:10)
```

* Неправильно спроектированный код, который приводит к возникновению такой ситуации

```
int[] array = new int[5];

System.out.println(array[8]);
```

## Работа с ошибками времени выполнения

* Самостоятельный выброс ошибок (если это действительно нужно)
  * Например, вы не можете получить данные с внешнего сервиса, об этом нужно сообщить путем выброса ошибки
* Уметь обрабатывать различные ошибки, которые возникают в системе так, чтобы в целом она не упала

## В контексте Java

* Ошибки мы называем "исключениями"/"exception"
* Каждое исключение, возникающее в программе - это объект, экземпляр какого-либо класса
* Есть возможность писать собственные классы исключений
* Выбросить исключение - создать объект класса-исключения
* `IllegalArgumentException` - встроенный класс-исключений, применяется, как правило, для выброса исключений, связанных с входными данными
* `throw` - выброс исключения (создание объекта класса-исключения и передача его Java-машине)
* `RuntimeException` - встроенный класс-исключений, от которого мы должны наследоваться, чтобы создавать свои классы с походящими названиями
* Если нам необходимо гарантировать наличие сообщения в исключении, то надо реализовать конструктор, принимающий это сообщение

## Обработка исключений

```
try {
    // код, в котором может возникнуть исключение
} catch (Exception e) {
    // код, который должен выполниться, если исключение появилось
}
```

* `Exception` - встроенный класс-исключение, который автоматически является предком для всех исключений 

## Варианты обработки исключений

* Мы можем писать `catch` для каждого типа исключения и прописывать отдельную реакцию на это. Если для какого-либо исключения catch не написан - то исключение будет причиной аварийного завершения программы.

```
        Scanner scanner = new Scanner(System.in);

        try {
            int size = scanner.nextInt();

            int[] array = new int[size];

            int a = scanner.nextInt();
            int b = scanner.nextInt();
            int c = a / b;

            array[1] = c;

            System.out.println(array[1]);
        } catch (InputMismatchException e) {
            System.out.println("Вы ввели что-то не то...");
        } catch (ArithmeticException e) {
            System.out.println("Вы пытаетесь поделить на ноль. Текст ошибки " + e.getMessage());
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Вам места в массиве не хватит");
        }
```

* Мы можем прописать одинаковую реакцию для нескольких исключений с помощью оператора "|"

```
        Scanner scanner = new Scanner(System.in);

        try {
            int size = scanner.nextInt();

            int[] array = new int[size];

            int a = scanner.nextInt();
            int b = scanner.nextInt();
            int c = a / b;

            array[1] = c;

            System.out.println(array[1]);
        } catch (InputMismatchException | ArithmeticException e) {
            System.out.println("Вы либо ввели что-то не то, либо на ноль пытаетесь поделить");
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Вам места в массиве не хватит");
        }

```

* Мы можем указать предка исключений и ловить всех потомков

```
        catch (RuntimeException e) {
            System.out.println("Получили какую-то ошибку");
        }
```

* Можно указывать потомков и писать для них специфичные действия, а все остальное съест предок

```
catch (InputMismatchException e) {
            System.out.println("Плохой ввод");
        } catch (RuntimeException e) {
            System.out.println("Получили какую-то ошибку");
        }
```

## Иерархия исключений

* Иерархия исключений описывает категории ошибок и методы работы с ними

* `Throwable` - класс, который содержит основные методы и поля для работы с исключениями
  * `private String detailMessage;` - текст сообщения об ошибке
  * `private StackTraceElement[] stackTrace` - стек вызовов, который привел к ошибке
* `Error` - как правило это системные ошибки, с которыми не надо ничего делать, они просто есть.
  * Закончилось место в оперативной памяти
  * Закончилось место на жестком диске
  * Поломка виртуальной машины
  * Сбой оборудования 
  * и т.д.
* `Exception` - пока отложим
* `RuntimeException` - все стандартные исключения, с которыми мы работаем. Свои исключения мы создаем также на основе `RuntimeException`